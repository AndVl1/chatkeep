/**
 * Channel Reply Contract Tests
 *
 * Verifies that the frontend can correctly deserialize backend responses
 * for channel reply endpoints.
 *
 * NOTE: Fixtures are generated by the backend CI pipeline.
 * If fixtures don't exist, these tests are skipped.
 */

import { describe, it, expect } from 'vitest';
import { loadJsonFixture, fixtureExists } from './contractTestUtils';
import type { ChannelReply } from '@/types';

describe('Channel Reply Contract', () => {
  it.skipIf(!fixtureExists('channel_reply_response.json'))(
    'should deserialize channel reply response from backend schema',
    () => {
      const result = loadJsonFixture<ChannelReply>('channel_reply_response.json');

      // Verify structure
      expect(result).toHaveProperty('enabled');
      expect(typeof result.enabled).toBe('boolean');

      expect(result).toHaveProperty('replyText');
      expect(result.replyText === null || typeof result.replyText === 'string').toBe(true);

      expect(result).toHaveProperty('mediaFileId');
      expect(result.mediaFileId === null || typeof result.mediaFileId === 'string').toBe(true);

      expect(result).toHaveProperty('mediaType');
      if (result.mediaType !== null) {
        expect(['PHOTO', 'VIDEO', 'DOCUMENT', 'ANIMATION']).toContain(result.mediaType);
      }

      expect(result).toHaveProperty('buttons');
      expect(Array.isArray(result.buttons)).toBe(true);

      // Verify button structure if present
      if (result.buttons.length > 0) {
        const button = result.buttons[0];
        expect(button).toHaveProperty('text');
        expect(typeof button.text).toBe('string');
        expect(button).toHaveProperty('url');
        expect(typeof button.url).toBe('string');
      }
    }
  );

  it.skipIf(!fixtureExists('channel_reply_update_request.json'))(
    'should serialize update request to backend schema',
    () => {
      const request = loadJsonFixture('channel_reply_update_request.json');

      // This fixture shows what the backend expects
      // Verify frontend sends compatible format
      expect(request).toBeDefined();
    }
  );

  it.skipIf(!fixtureExists('media_upload_response.json'))(
    'should deserialize media upload response',
    () => {
      const result = loadJsonFixture<{ fileId: string; mediaType: string }>('media_upload_response.json');

      expect(result).toHaveProperty('fileId');
      expect(typeof result.fileId).toBe('string');

      expect(result).toHaveProperty('mediaType');
      expect(['PHOTO', 'VIDEO', 'DOCUMENT', 'ANIMATION']).toContain(result.mediaType);
    }
  );
});
